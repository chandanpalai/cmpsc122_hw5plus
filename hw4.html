<html>
<STYLE type="text/css">
OL.withalpha { list-style-type: lower-alpha }
</STYLE>
<center>
<h3>CMPSC 122<br>
Fall 2015</h3>

<h3>Homework IV<br>
16 October 2015</h3>
</center>

This assignment incorporates a more complete object-oriented
design into the project, including inheritance and polymorphism
from derived classes.
<p>
<h4>PROBLEM DESCRIPTION</h4>
<p>
Not all programs running on a system at any given time have the same
behavior.  There may be one or two that are directly interacting with
a human being, while others are downloading information from a network.
Some larger systems would also be occasionally saving data onto 
long-term secondary storage in the background.
<p>
Simulating process scheduling for such a varied set of processes
would be much simplified if they could all be represented in a
uniform and simple way.
<p>
Similarly, there are many different ways for an operating system to
choose which of these several processes to run.  If we wish a simulation
to adequately compare these various policies to each other, it would
be much simplified if all the scheduling policies could be
represented in a uniform way.
<p>
Object-oriented programming with inheritance is a very useful
programming technique, because it allows an interface to interact
with a base class, while the details of the operations are 
implemented in derived classes. 
<p>
<h4>INHERITANCE DEFINED FOR THIS ASSIGNMENT</h4>
<h5><tt>device.h</tt> and <tt>device.cpp</tt></h5>
A new object type appearing this week is the <tt>Device</tt>,
that represents any peripheral device that a process may choose
to interact with.  For this assignment, there will be the disk,
the network, and the console (keyboard and screen).
<p>
For simplicity, all of these devices will appear to have the same
behavior from the point of view of the process -- something that
takes time to respond.  The keyboard and the screen are folded into
one object modeling the possibility that a user types at the 
keyboard in response to seeing something on the screen.  One additional
'cpu' object is declared in this category only for simplifying an
interface elsewhere.
<p>
The method <tt>Device::request</tt> accomplishes the same thing
as <tt>diskRequest</tt> in the previous assignment.  It is simply
generalized to apply to work for any of the derived classes.
<p>
<h5><tt>process.h</tt> and <tt>process.cpp</tt></h5>
Three different sorts of processes are defined for this exercise.
A <tt>Computation</tt> represents a program that uses relatively
large bursts of CPU, occasionally separated by some access to a disk,
either for data or virtual memory.  A <tt>Download</tt> process
represents a program that fetches data from a network and stored
it onto the disk.  And one process type is defined to simply
<tt>Interact</tt> with a user at the console.   The simulation
will work with a mixture of these types of processes.
<p>
<h5><tt>scheduler.h</tt></h5>
The Scheduler object is now used as the basis for four different
scheduling policies -- two which had been seen before, and
two more, which will be discussed in more detail below.
<p>
<h4>ASSIGNMENT DETAILS</h4>
Most of the work for this assignment will be simply adapting
the previous assignment to the new object-oriented environment.
<p>
1) The array of Processes has been changed to be an array 
of pointers to Processes, to allow the use of the derived classes
for Process.   The function prototypes for <tt>displayHistory</tt>,
<tt>scheduler:::runScheduler</tt> and <tt>Device::request</tt> have
been changed for you, but the use of these variables will require
some minor editing.  In most cases, it will be nothing more than
replacing <tt>.</tt> with <tt>-></tt> to follow the pointer
before accessing an object member.
<p>
2) When a process is done executing, instead of returning a character
representing its next state, it will return a pointer to a Device
object.  If it wishes to access a peripheral, it will indicate which one.
If it still has more work to do with the CPU, it will return a pointer
to that object.  If it is done, it may return a NULL pointer.
The <tt>Scheduler::runScheduler</tt> code will then need to
properly handle this change.
<p>
3) The only "new" code will be the completion of the two new
objects defined in <tt>scheduler.h</tt>.  
<ul><li>
Priority scheduling
will simply use the process identifier (<tt>procId</tt>) for its 
choice, choosing the process with the largest value to be the
highest priority.  This ordering can be accomplished simply by
replacing the behavior of <tt>addProcess</tt>.
<li>Preemptive priority scheduling will also choose the process
that has the highest process identifier.  It only differs from
priority scheduling in that the highest priority process will 
be allowed to run as soon as it arrives.  This can be effectively
simulated simply by changing the behavior of the <tt>allowance</tt> method.
</ul>
The credit for this new code will depend in part on the clarity
and simplicity of the solution, as well as its correctness.<br>
HINT: Time is not relevant in the decision to choose a process from
those that are currently ready to run.
